function [bestVel,bestPos,insAtt] = readGpsImu_span(dataSetID,gpsPath)
% Project           :: Optical Odometer
% Author            :: Kenneth Laws
%                   :: Here Technologies
% Creation Date     :: 12/14/2017
%
% Reads data file generated by my stand-alone span setup
% span logging is configured and controlled by use of a command file

if exist(['data/' dataSetID '_gpsIns.mat'])
    load(['data/' dataSetID '_gpsIns.mat']);
else
    
    % open the file
    fid = fopen([gpsPath 'span6.txt']);
    
    % load in the data
    %data = csvread([gpsPath gpsFile]);
    pos_xyz = [];
    bestPos = [];
    bestVel = [];
    insAtt = [];
    
    while ~feof(fid)
        textLine = fgetl(fid);
        fields = strfind(textLine,',');
        type = textLine(1:fields(1)-1);
        if strcmp(type,'#BESTXYZA')     % position in earth centered cartesian coordinates
            xyzTime = textLine(fields(6)+1:fields(7)-1);
            x = textLine(fields(11)+1:fields(12)-1);
            y = textLine(fields(12)+1:fields(13)-1);
            z = textLine(fields(13)+1:fields(14)-1);
        end
        if strcmp(type,'#BESTVELA')
            velTime = textLine(fields(6)+1:fields(7)-1);
            velLatency = textLine(fields(11)+1:fields(12)-1); % A measure of the latency in the velocity time tagin seconds. It should be subtracted from the time to give improved results (s)
            age = textLine(fields(12)+1:fields(13)-1); % Differential age in seconds
            hSpd = textLine(fields(13)+1:fields(14)-1); % Horizontal speed over ground, in m/s
            headng = textLine(fields(14)+1:fields(15)-1); % Actual direction of motion over ground (track over ground) with respect to True North, in degrees
            vSpd = textLine(fields(15)+1:fields(16)-1); % vertical speed, in metres per second, where positive values indicate increasing altitude (up) and negative values indicate decreasing altitude (down)
            bestVel = [bestVel; str2double({velTime,velLatency,hSpd,headng,vSpd})];
        end
        if strcmp(type,'#BESTPOSA')
            posTime = textLine(fields(6)+1:fields(7)-1);
            bestLat = textLine(fields(11)+1:fields(12)-1); % Latitude (degrees)
            bestLon = textLine(fields(12)+1:fields(13)-1); % Longitude (degrees)
            bestHeight = textLine(fields(13)+1:fields(14)-1); % Height above mean sea level (metres)
            bestPos = [bestPos; str2double({posTime,bestLat,bestLon,bestHeight})];
        end
        if strcmp(type,'#INSATTA')
            insTime = textLine(fields(6)+1:fields(7)-1);
            roll = textLine(fields(11)+1:fields(12)-1); % Right-handed rotation from local level around y-axis in degrees
            pitch = textLine(fields(12)+1:fields(13)-1); % Right-handed rotation from local level around axis in degrees
            azmth = textLine(fields(13)+1:fields(14)-1); % Left-handed rotation around z-axis in degrees clockwise from North. This is the inertial azimuth calculated from the IMU gyros and the SPAN filters.
            insAtt = [insAtt; str2double({insTime,roll,pitch,azmth})];
        end
    end
    save(['data/' dataSetID '_gpsIns.mat'],'bestVel','bestPos','insAtt');
end
return



